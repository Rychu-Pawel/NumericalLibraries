using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Diagnostics;
using NumericalLibraries.Bessel;
using NumericalLibraries.Chart.Exceptions;
using NumericalLibraries.Calculator.Enums;
using NumericalLibraries.Calculator.Exceptions;
using NumericalLibraries.Chart.Enums;
using NumericalLibraries.Common;

namespace NumericalLibraries.Chart
{
    public class Chart
    {
    // Zmienne ----------------------------
        double xFrom, xTo, yFrom, yTo; //Chosen range
        double zeroX, zeroY; //Where is the zero
        double factorX, factorY; //X and Y factors - how many units on the graph one user's unit has
        int picWidth, picHeight;

        readonly double max = 530000000.0;
        readonly double min = -530000000.0;

        PictureBox pChart;
        Graphics g;

        string function;

        Image img;

        public Image Image
        {
          get { return img; }
        }

        List<PointF> chartPoints;

        /// <summary>
        /// Points generated by Draw functions used to draw the chart 
        /// </summary>
        public PointF[] GraphPoints
        {
            get { return chartPoints.ToArray(); }
        }

    // Metody -----------------------------
        /// <summary>
        /// Clears old chart and generates new clear chart with coordinate system
        /// </summary>
        public void Clear()
        {
            Font font = new Font("Arial", 7);

            g.Clear(Color.White);

            //Draw X net:
            double step = ((-xFrom + xTo) / 6) * factorX;

            if (xFrom * xTo <= 0) // zeroX axis will be visible so draw from zeroX to left and from zeroX to right
            {
                for (double i = zeroX; i >= zeroX + xFrom * factorX; i -= step)
                {
                    if (i > (xFrom * factorX) + zeroX && i < (xTo * factorX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // AXIS -X
                        g.DrawString(Convert.ToString(Math.Round(xFrom + i / factorX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }

                for (double i = zeroX; i <= (xTo * factorX) + zeroX; i += step)
                {
                    if (i > (xFrom * factorX) + zeroX && i < (xTo * factorX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // AXIS +X
                        g.DrawString(Convert.ToString(Math.Round(xFrom + i / factorX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }
            }
            else if (xFrom < 0) // xFrom and xTo are negative
            {
                for (double i = zeroX; i >= zeroX + xFrom * factorX; i -= step)
                {
                    if (i > (xFrom * factorX) + zeroX && i < (xTo * factorX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // AXIS -X
                        g.DrawString(Convert.ToString(Math.Round(xFrom + i / factorX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }
            }
            else // both are positive
            {
                for (double i = zeroX; i <= (xTo * factorX) + zeroX; i += step)
                {
                    if (i > (xFrom * factorX) + zeroX && i < (xTo * factorX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // AXIS +X
                        g.DrawString(Convert.ToString(Math.Round(xFrom + i / factorX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }
            }

            //Draw Y net:
            step = ((-yFrom + yTo) / 6) * factorY;

            if (yFrom * yTo <= 0) // zeroY axis will be visible so draw from zeroY to left and from zeroY to right
            {
                for (double i = zeroY; i <= zeroY + (-yFrom) * factorY; i += step)
                {
                    if (i < (-yFrom * factorY) + zeroY && i > (-yTo * factorY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // AXIS -Y
                        g.DrawString(Convert.ToString(Math.Round(yTo - i / factorY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }

                for (double i = zeroY; i >= zeroY + (-yTo) * factorY; i -= step)
                {
                    if (i < (-yFrom * factorY) + zeroY && i > (-yTo * factorY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // AXIS +Y
                        g.DrawString(Convert.ToString(Math.Round(yTo - i / factorY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }
            }
            else if (yFrom < 0) // both yOd and yDo are negative
            {
                for (double i = zeroY; i <= zeroY + (-yFrom) * factorY; i += step)
                {
                    if (i < (-yFrom * factorY) + zeroY && i > (-yTo * factorY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // AXIS -Y
                        g.DrawString(Convert.ToString(Math.Round(yTo - i / factorY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }
            }
            else // both positive
            {
                for (double i = zeroY; i >= zeroY + (-yTo) * factorY; i -= step)
                {
                    if (i < (-yFrom * factorY) + zeroY && i > (-yTo * factorY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // AXIS +Y
                        g.DrawString(Convert.ToString(Math.Round(yTo - i / factorY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }
            }

            //DRAW AXIS OX AND OY
            g.DrawLine(Pens.Black, 0, (float)zeroY, img.Width, (float)zeroY); // AXIS X
            g.DrawLine(Pens.Black, (float)zeroX, 0, (float)zeroX, img.Height); // AXIS Y

            font = new Font("Aria", 8);

            //ARROWS AND DESCRIPTION OF OX
            g.DrawLine(Pens.Black, (float)img.Width - 12f, (float)zeroY - 5f, (float)img.Width - 2f, (float)zeroY);
            g.DrawLine(Pens.Black, (float)img.Width - 12f, (float)zeroY + 5f, (float)img.Width - 2f, (float)zeroY);
            g.DrawString("x", font, Brushes.Black, (float)img.Width - 13f, (float)zeroY + 3f);

            //ARROWS AND DESCRIPTION OF OY
            g.DrawLine(Pens.Black, (float)zeroX - 6f, 10f, (float)zeroX - 1, 2);
            g.DrawLine(Pens.Black, (float)zeroX + 5f, 10f, (float)zeroX + 1, 2);
            g.DrawString("f(x)", font, Brushes.Black, (float)zeroX + 7f, 4f);

            //Clear chart points
            chartPoints = new List<PointF>();
        }

        /// <summary>
        /// Draw the chart
        /// </summary>
        /// <param name="functionType">Function type to draw on chart</param>
        public void Draw(FunctionTypeEnum functionType)
        {
            chartPoints.Clear();

            Derivative.Derivative functionInThePoint = new Derivative.Derivative(function);

            Font font2 = new Font("Arial", 8);

            List<PointF> points = new List<PointF>();

            Pen pen = null;

            for (double i = 0; i < picWidth; i += (double)picWidth / 1000.0)
            {
                float fx = 0;
                double x = (i - zeroX) / factorX;

                switch (functionType)
                {
                    case FunctionTypeEnum.Function:
                        fx = (float)(functionInThePoint.ComputeFunctionAtPoint(x) * factorY);
                        break;
                    case FunctionTypeEnum.Derivative:
                        fx = (float)(functionInThePoint.ComputeDerivative(x) * factorY);
                        break;
                    case FunctionTypeEnum.SecondDerivative:
                        fx = (float)(functionInThePoint.ComputeDerivativeBis(x) * factorY);
                        break;
                    default:
                        throw new NoneGraphOptionCheckedException(); //not reachable code?
                }

                if (fx > max)
                    fx = (float)max;
                else if (fx < min)
                    fx = (float)min;

                points.Add(new PointF((float)(i), (float)(zeroY - fx)));
                chartPoints.Add(new PointF((float)x, (float)(fx / factorY)));
            }

            //Draw formula
            g.DrawString("f(x) = " + function, font2, Brushes.Black, 3, 3);

            switch (functionType)
            {
                case FunctionTypeEnum.Function:
                    pen = Pens.Blue;
                    break;
                case FunctionTypeEnum.Derivative:
                    pen = Pens.Red;
                    break;
                case FunctionTypeEnum.SecondDerivative:
                    pen = Pens.Green;
                    break;
            }

            //Draw the chart
            try
            {
                g.DrawLines(pen, points.ToArray());
            }
            catch (Exception)
            {
                //Get rid of the NaN
                points = points.Where(p => !double.IsNaN(p.Y)).ToList();

                try
                {
                    g.DrawLines(pen, points.ToArray());
                }
                catch { }
            }           
        }

        /// <summary>
        /// Draw the fourier transform chart
        /// </summary>
        /// <param name="functionType">Function type to draw. Only FT or IFT are correct in this function.</param>
        /// <param name="sampling">Sampling rate</param>
        /// <param name="cutoff">Used with IFT to remove noise from function</param>
        public void DrawFT(FunctionTypeEnum functionType, int sampling, double cutoff = 0.0)
        {
            chartPoints.Clear();

            Font font2 = new Font("Arial", 8);

            List<PointF> points = new List<PointF>();
            List<PointF> pointsReversed = new List<PointF>();

            List<PointC> pointsC = new List<PointC>();
            List<PointC> pointsReversedC = new List<PointC>();

            Pen pen = null;

            FourierTransform.FourierTransform fft = new FourierTransform.FourierTransform();

            //Compute FT
            pointsC = fft.Compute(function, sampling, xFrom, xTo);

            //Filter out
            for (int i = 0; i < pointsC.Count; i++)
            {
                PointC pc = pointsC[i];

                if (Math.Abs(pc.Y.Real) < cutoff)
                    pc.Y = 0;

                pointsC[i] = pc;
            }

            //Compute Reverse FT
            if (functionType == FunctionTypeEnum.IFT)
                pointsReversedC = fft.ComputeInverse(pointsC, sampling, xFrom, xTo);

            //new preparation
            if (functionType == FunctionTypeEnum.FT)
                Initialize(function, img.Width, img.Height, 0, sampling + 3, yFrom, yTo);

            //Rescale of the points
            if (functionType == FunctionTypeEnum.FT)
            {
                for (int i = 0; i < pointsC.Count; i++)
                {
                    PointC pc = pointsC[i];

                    chartPoints.Add(pc.ToPointF());

                    pc.X = (pc.X * factorX + zeroX);
                    pc.Y = (pc.Y * factorY);

                    if (pc.Y.Real > max)
                        pc.Y = max;
                    else if (pc.Y.Real < min)
                        pc.Y = min;

                    pc.Y = (zeroY - pc.Y);

                    points.Add(pc.ToPointF());
                }
            }

            if (functionType == FunctionTypeEnum.IFT)
            {
                //rescale of the Reverse points
                for (int i = 0; i < pointsReversedC.Count; i++)
                {
                    PointC pc = pointsReversedC[i];

                    chartPoints.Add(pc.ToPointF());

                    pc.X = (pc.X * factorX + zeroX);
                    pc.Y = (pc.Y * factorY);

                    if (pc.Y.Real > max)
                        pc.Y = max;
                    else if (pc.Y.Real < min)
                        pc.Y = min;

                    //if (Math.Abs(pc.Y.Real) < odciecie)
                    //    pc.Y = 0;

                    pc.Y = (zeroY - pc.Y);

                    pointsReversed.Add(pc.ToPointF());
                }
            }

            //Draw the formula
            if (functionType == FunctionTypeEnum.FT)
                g.DrawString("FFT(" + '\u03C9' + ") = " + function, font2, Brushes.Black, 3, 16);
            else
                g.DrawString("RFFT(x) = " + function, font2, Brushes.Black, 3, 16);

            switch (functionType)
            {
                case FunctionTypeEnum.FT:
                    pen = Pens.PaleVioletRed;
                    break;
                case FunctionTypeEnum.IFT:
                    pen = Pens.Red;
                    break;
                default:
                    pen = Pens.Red;
                    break;
            }

            //Draw the graph
            try
            {
                if (functionType == FunctionTypeEnum.FT)
                    g.DrawLines(pen, points.ToArray());
                else
                    g.DrawLines(pen, pointsReversed.ToArray());
            }
            catch (Exception)
            {
                //Get rid of the NaN
                if (functionType == FunctionTypeEnum.FT)
                    points = points.Where(p => !double.IsNaN(p.Y)).ToList();
                else
                    pointsReversed = pointsReversed.Where(p => !double.IsNaN(p.Y)).ToList();

                try
                {
                    if (functionType == FunctionTypeEnum.FT)
                        g.DrawLines(pen, points.ToArray());
                    else
                        g.DrawLines(pen, pointsReversed.ToArray());
                }
                catch { }
            }
        }

        /// <summary>
        /// Draw the differential chart
        /// </summary>
        /// <param name="functionType">Function type. Only Differential or DifferentialII are correct in this function.</param>
        /// <param name="parameters">
        /// 0. Starting point
        /// 1. Starting point function value
        /// 2. Second derivative starting point function value
        /// </param>
        public void DrawDifferential(FunctionTypeEnum functionType, params double[] parameters)
        {
            chartPoints.Clear();

            List<PointF> points = new List<PointF>();

            Font font2 = new Font("Arial", 8);

            Pen pen = null;

            //Adjust the step
            double step = 0.001;
            double range = xTo - xFrom;

            if (range > 20 && range < 50)
                step = 0.0025;
            else if (range >= 50 && range < 150)
                step = 0.005;
            else if (range >= 150 && range < 500)
                step = 0.01;
            else if (range >= 500)
                step = 0.05;

            //Move to the left edge then the right edge
            switch (functionType)
            {
                case FunctionTypeEnum.Differential:

                    Differential.Differential differential = new Differential.Differential(function);

                    List<PointD> left = new List<PointD>();
                    List<PointD> right = new List<PointD>();

                    //Left
                    if (xFrom < parameters[0])
                        left = differential.ComputeDifferentialPointsList(xFrom, parameters[0], parameters[1], false, step);

                    //Right
                    differential = new Differential.Differential(function);

                    if (xTo >= parameters[0])
                        right = differential.ComputeDifferentialPointsList(xTo, parameters[0], parameters[1], false, step);

                    //Join
                    //Reverse to the left
                    left.Reverse();

                    //Add left
                    foreach (PointD point in left)
                    {
                        PointF pf = new PointF();

                        chartPoints.Add(point.ToPointF());

                        pf.X = (float)(point.X * factorX + zeroX);
                        pf.Y = (float)(point.Y * factorY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        points.Add(pf);
                    }

                    //Add right
                    foreach (PointD point in right)
                    {
                        PointF pf = new PointF();

                        chartPoints.Add(point.ToPointF());

                        pf.X = (float)(point.X * factorX + zeroX);
                        pf.Y = (float)(point.Y * factorY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        points.Add(pf);
                    }

                    break;
                case FunctionTypeEnum.DifferentialII:

                    Differential.Differential differentialII = new Differential.Differential(function);

                    List<PointD> leftII = new List<PointD>();
                    List<PointD> rightII = new List<PointD>();

                    //Left
                    if (xFrom < parameters[0])
                        leftII = differentialII.ComputeDifferentialIIPointsList(xFrom, parameters[0], parameters[1], parameters[2], false, step);

                    //Right
                    differentialII = new Differential.Differential(function);

                    if (xTo >= parameters[0])
                        rightII = differentialII.ComputeDifferentialIIPointsList(xTo, parameters[0], parameters[1], parameters[2], false, step);

                    //JOIN
                    //Reverse left
                    leftII.Reverse();

                    //Add left
                    foreach (PointD point in leftII)
                    {
                        //Normal:
                        PointF pf = new PointF();

                        chartPoints.Add(point.ToPointF());

                        pf.X = (float)(point.X * factorX + zeroX);
                        pf.Y = (float)(point.Y * factorY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        points.Add(pf);
                    }

                    //Add right
                    foreach (PointD point in rightII)
                    {
                        //Normal:
                        PointF pf = new PointF();

                        chartPoints.Add(point.ToPointF());

                        pf.X = (float)(point.X * factorX + zeroX);
                        pf.Y = (float)(point.Y * factorY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        points.Add(pf);
                    }

                    break;
                default:
                    throw new NoneGraphOptionCheckedException(); //not reachable code?
            }

            //Draw the formula
            g.DrawString("f(x) = " + function, font2, Brushes.Black, 3, 3);

            switch (functionType)
            {
                case FunctionTypeEnum.Differential:
                    pen = Pens.PaleVioletRed;
                    break;
                case FunctionTypeEnum.DifferentialII:
                    pen = Pens.Maroon;
                    break;
            }

            //Draw the chart
            try
            {
                g.DrawLines(pen, points.ToArray());
            }
            catch (Exception)
            {
                //Get rid of the NaN
                points = points.Where(p => !double.IsNaN(p.Y)).ToList();
                
                try
                {
                    g.DrawLines(pen, points.ToArray());
                }
                catch { }
            }
        }

        /// <summary>
        /// Drawing the Bessel, Neumann or Hypergeometric functions chart
        /// </summary>
        /// <param name="functionType">Function type to draw</param>
        /// <param name="parameters">Chosen function parameters</param>
        public void DrawBessel(BesselFunctionTypeEnum functionType, params double[] parameters)
        {
            chartPoints.Clear();

            int variableIndex = FindVariableIndex(functionType, parameters);

            BesselNeumanHyper bnh = new BesselNeumanHyper();
            List<PointF> points = new List<PointF>();

            //Compute the points
            if (variableIndex != -1)
            {
                for (double i = 0; i < picWidth; i += (double)picWidth / 1000.0)
                {
                    float fx = 0;
                    parameters[variableIndex] = (i - zeroX) / factorX;

                    switch (functionType)
                    {
                        case BesselFunctionTypeEnum.Bessel:
                            fx = (float)(bnh.Bessel(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.BesselSphere:
                            fx = (float)(bnh.SphBessel(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.BesselSphereDerivative:
                            fx = (float)(bnh.SphBesselPrim(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.Neumann:
                            fx = (float)(bnh.Neumann(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphere:
                            fx = (float)(bnh.SphNeuman(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphereDerivative:
                            fx = (float)(bnh.SphNeumanPrim(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric01:
                            fx = (float)(bnh.Hyperg_0F_1(parameters[0], parameters[1]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric11:
                            fx = (float)(bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]) * factorY);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric21:
                            fx = (float)(bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]) * factorY);
                            break;
                        default:
                            throw new Exception("No function has been chosen!"); //not reachable code?
                    }

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    points.Add(new PointF((float)(i), (float)(zeroY - fx)));
                    chartPoints.Add(new PointF((float)parameters[variableIndex], (float)(fx / factorY)));
                }
            }
            else //Add two points - constant function
            {
                float fx = 0;

                switch (functionType)
                {
                    case BesselFunctionTypeEnum.Bessel:
                        fx = (float)(bnh.Bessel(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.BesselSphere:
                        fx = (float)(bnh.SphBessel(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.BesselSphereDerivative:
                        fx = (float)(bnh.SphBesselPrim(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.Neumann:
                        fx = (float)(bnh.Neumann(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphere:
                        fx = (float)(bnh.SphNeuman(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphereDerivative:
                        fx = (float)(bnh.SphNeumanPrim(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric01:
                        fx = (float)(bnh.Hyperg_0F_1(parameters[0], parameters[1]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric11:
                        fx = (float)(bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]) * factorY);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric21:
                        fx = (float)(bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]) * factorY);
                        break;
                    default:
                        throw new Exception("No function has been chosen!"); //not reachable code?
                }

                if (fx > max)
                    fx = (float)max;
                else if (fx < min)
                    fx = (float)min;

                points.Add(new PointF((float)(0), (float)(zeroY - fx)));
                points.Add(new PointF((float)(picWidth), (float)(zeroY - fx)));
            }         
            
            //Draw the chart
            try
            {
                g.DrawLines(Pens.Orange, points.ToArray());
            }
            catch (Exception)
            {
                //Get rid of the NaN
                points = points.Where(p => !double.IsNaN(p.Y)).ToList();

                try
                {
                    g.DrawLines(Pens.Orange, points.ToArray());
                }
                catch { }
            }            
        }

        /// <summary>
        /// Function that returns reskalled chart parameters
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </summary>
        /// <param name="functionType">Function type</param>
        /// <returns>
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </returns>
        public double[] Reskalling(params FunctionTypeEnum[] functionType)
        {
            Derivative.Derivative functionValueInAPoint = new Derivative.Derivative(function); // To compute function value in a point
            List<PointF> points = new List<PointF>();

            //Compute the points
            for (double i = 0; i < picWidth; i += (double)picWidth / 100.0)
            {
                float fx = 0;
                double thePoint = (i - zeroX) / factorX;

                if (functionType.Contains(FunctionTypeEnum.Function))
                {
                    fx = (float)functionValueInAPoint.ComputeFunctionAtPoint(thePoint);

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    points.Add(new PointF((float)thePoint, fx));
                }

                if (functionType.Contains(FunctionTypeEnum.Derivative))
                {
                    fx = (float)functionValueInAPoint.ComputeDerivative(thePoint);

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    points.Add(new PointF((float)thePoint, fx));
                }

                if (functionType.Contains(FunctionTypeEnum.SecondDerivative))
                {
                    fx = (float)functionValueInAPoint.ComputeDerivativeBis(thePoint);

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    points.Add(new PointF((float)thePoint, fx));
                }
            }

            //Wyciagniecie punktow bez NaN
            List<PointF> newPoints = points.Where(pkt => (!double.IsNaN(pkt.Y) && !double.IsInfinity(pkt.Y))).ToList();

            if (newPoints.Count == 0)
                return new double[] { xFrom, xTo, yFrom, yTo };

            double minX, maxX;

            //Rescale the chart if there were any NaNs
            if (points.Count() > newPoints.Count())
            {
                minX = newPoints.Select(p => p.X).Min();
                maxX = newPoints.Select(p => p.X).Max();

                //Compute +-1%
                double onePercentX = Math.Abs(maxX - minX) * 0.01;

                minX += onePercentX;
                maxX -= onePercentX;

                minX = Math.Round(minX, 2);
                maxX = Math.Round(maxX, 2);

                Chart chart = new Chart(function, pChart, minX, maxX, yFrom, yTo);

                return chart.Reskalling(functionType);
            }

            double maxY = newPoints.Select(p => p.Y).Max();
            double minY = newPoints.Select(p => p.Y).Min();

            //Compute +-5%
            double fivePercentY = Math.Abs(maxY - minY) * 0.05;

            maxY += fivePercentY;
            minY -= fivePercentY;

            maxY = Math.Round(maxY, 2);
            minY = Math.Round(minY, 2);

            if (maxY > max)
                maxY = (float)max;
            else if (maxY < min)
                maxY = (float)min;

            if (minY > max)
                minY = (float)max;
            else if (minY < min)
                minY = (float)min;

            if (minY == maxY)
            {
                minY -= 0.5;
                maxY += 0.5;
            }

            double[] f = new double[] { xFrom, xTo, minY, maxY };

            return f;
        }

        /// <summary>
        /// Function that returns reskalled chart parameters for Bessel, Neumann or Hypergeometric functions
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </summary>
        /// <param name="functionType">Function type</param>
        /// <param name="parameters">Chosen function parameters</param>
        /// <returns>
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </returns>
        public double[] Reskalling(BesselFunctionTypeEnum functionType, params double[] parameters)
        {
            int variableIndex = FindVariableIndex(functionType, parameters);

            BesselNeumanHyper bnh = new BesselNeumanHyper();
            List<PointF> points = new List<PointF>();

            //Compute the points
            if (variableIndex != -1)
            {
                for (double i = 0; i < picWidth; i += (double)picWidth / 100.0)
                {
                    float fx = 0;
                    parameters[variableIndex] = (i - zeroX) / factorX;

                    switch (functionType)
                    {
                        case BesselFunctionTypeEnum.Bessel:
                            fx = (float)bnh.Bessel(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.BesselSphere:
                            fx = (float)bnh.SphBessel(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.BesselSphereDerivative:
                            fx = (float)bnh.SphBesselPrim(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.Neumann:
                            fx = (float)bnh.Neumann(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphere:
                            fx = (float)bnh.SphNeuman(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphereDerivative:
                            fx = (float)bnh.SphNeumanPrim(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric01:
                            fx = (float)bnh.Hyperg_0F_1(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric11:
                            fx = (float)bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric21:
                            fx = (float)bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]);
                            break;
                        default:
                            throw new Exception("No function has been chosen!"); //not reachable code?
                    }

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    points.Add(new PointF((float)(parameters[variableIndex]), fx));
                }
            }
            else //Add two points - constant function
            {
                float fx = 0;

                switch (functionType)
                {
                    case BesselFunctionTypeEnum.Bessel:
                        fx = (float)bnh.Bessel(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.BesselSphere:
                        fx = (float)bnh.SphBessel(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.BesselSphereDerivative:
                        fx = (float)bnh.SphBesselPrim(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.Neumann:
                        fx = (float)bnh.Neumann(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphere:
                        fx = (float)bnh.SphNeuman(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphereDerivative:
                        fx = (float)bnh.SphNeumanPrim(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric01:
                        fx = (float)bnh.Hyperg_0F_1(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric11:
                        fx = (float)bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric21:
                        fx = (float)bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]);
                        break;
                    default:
                        throw new Exception("No function has been chosen!"); //not reachable code?
                }

                if (fx > max)
                    fx = (float)max;
                else if (fx < min)
                    fx = (float)min;

                points.Add(new PointF((float)((0 - zeroX) / factorX), fx));
                points.Add(new PointF((float)((picWidth - zeroX) / factorX), fx));
            }

            //Skip NaN
            List<PointF> newPoints = points.Where(pkt => (!double.IsNaN(pkt.Y) && !double.IsInfinity(pkt.Y))).ToList();

            if (newPoints.Count == 0)
                return new double[] { xFrom, xTo, yFrom, yTo};

            double minX, maxX;

            //If there were any NaNs then change X i rescal again
            if (points.Count() > newPoints.Count())
            {
                minX = newPoints.Select(p => p.X).Min();
                maxX = newPoints.Select(p => p.X).Max();

                //Compute +-1%
                double onePercentX = Math.Abs(maxX - minX) * 0.01;

                minX += onePercentX;
                maxX -= onePercentX;

                minX = Math.Round(minX, 2);
                maxX = Math.Round(maxX, 2);

                Chart chart = new Chart(function, pChart, minX, maxX, yFrom, yTo);

                parameters[variableIndex] = double.NaN;

                return chart.Reskalling(functionType, parameters);
            }

            double maxY = newPoints.Select(p => p.Y).Max();
            double minY = newPoints.Select(p => p.Y).Min();

            //Compute +-5%
            double fivePercentY = Math.Abs(maxY - minY) * 0.05;

            maxY += fivePercentY;
            minY -= fivePercentY;

            maxY = Math.Round(maxY, 2);
            minY = Math.Round(minY, 2);

            if (maxY > max)
                maxY = (float)max;
            else if (maxY < min)
                maxY = (float)min;

            if (minY > max)
                minY = (float)max;
            else if (minY < min)
                minY = (float)min;

            if (minY == maxY)
            {
                minY -= 0.5;
                maxY += 0.5;
            }

            double[] f = new double[] { xFrom, xTo, minY, maxY };            

            return f;
        }

        private int FindVariableIndex(BesselFunctionTypeEnum functionType, double[] parameters)
        {
            int variableIndex = -1;
            
            if (functionType == BesselFunctionTypeEnum.Bessel || functionType == BesselFunctionTypeEnum.BesselSphere || functionType == BesselFunctionTypeEnum.BesselSphereDerivative || functionType == BesselFunctionTypeEnum.Neumann || functionType == BesselFunctionTypeEnum.NeumannSphere || functionType == BesselFunctionTypeEnum.NeumannSphereDerivative || functionType == BesselFunctionTypeEnum.Hypergeometric01)
            {
                if (double.IsNaN(parameters[0]))
                    variableIndex = 0;

                if (double.IsNaN(parameters[1]))
                {
                    if (variableIndex == -1)
                        variableIndex = 1;
                    else
                        throw new BesseleSecondArgumentException();
                }
            }
            else if (functionType == BesselFunctionTypeEnum.Hypergeometric11)
            {
                if (double.IsNaN(parameters[0]))
                    variableIndex = 0;

                if (double.IsNaN(parameters[1]))
                {
                    if (variableIndex == -1)
                        variableIndex = 1;
                    else
                        throw new BesseleSecondArgumentException();
                }

                if (double.IsNaN(parameters[2]))
                {
                    if (variableIndex == -1)
                        variableIndex = 2;
                    else
                        throw new BesseleThirdArgumentException();
                }
            }
            else if (functionType == BesselFunctionTypeEnum.Hypergeometric21)
            {
                if (double.IsNaN(parameters[0]))
                    variableIndex = 0;

                if (double.IsNaN(parameters[1]))
                {
                    if (variableIndex == -1)
                        variableIndex = 1;
                    else
                        throw new BesseleSecondArgumentException();
                }

                if (double.IsNaN(parameters[2]))
                {
                    if (variableIndex == -1)
                        variableIndex = 2;
                    else
                        throw new BesseleThirdArgumentException();
                }

                if (double.IsNaN(parameters[3]))
                {
                    if (variableIndex == -1)
                        variableIndex = 3;
                    else
                        throw new BesseleFourthArgumentException();
                }
            }

            return variableIndex;
        }
        
        /// <summary>
        /// Chart constructor
        /// </summary>
        /// <param name="function">Function formula to draw</param>
        /// <param name="picGraph">PictureBox to display the chart</param>
        /// <param name="xFrom">Chart abscissa from</param>
        /// <param name="xTo">Chart abscissa to</param>
        /// <param name="yFrom">Chart cordinate from</param>
        /// <param name="yTo">Chart cordinate to</param>
        public Chart(string function, PictureBox picGraph, double xFrom, double xTo, double yFrom, double yTo)
        {
            this.pChart = picGraph;

            Initialize(function, picGraph.Width, picGraph.Height, xFrom, xTo, yFrom, yTo);
        }

        /// <summary>
        /// Chart constructor
        /// </summary>
        /// <param name="function">Function formula to draw</param>
        /// <param name="width">Picture width</param>
        /// <param name="height">Picture height</param>
        /// <param name="xFrom">Chart abscissa from</param>
        /// <param name="xTo">Chart abscissa to</param>
        /// <param name="yFrom">Chart cordinate from</param>
        /// <param name="yTo">Chart cordinate to</param>
        public Chart(string function, int width, int height, double xFrom, double xTo, double yFrom, double yTo)
        {
            this.pChart = new PictureBox();
            pChart.Width = width;
            pChart.Height = height;

            Initialize(function, width, height, xFrom, xTo, yFrom, yTo);
        }

        private void Initialize(string func, int width, int height, double xFrom, double xTo, double yFrom, double yTo)
        {
            if (xTo == xFrom)
                throw new CoordinatesXException();

            if (yTo == yFrom)
                throw new CoordinatesYException();

            function = func;
            picWidth = width;
            picHeight = height;

            img = new Bitmap(picWidth, picHeight);
            pChart.Image = img;
            g = Graphics.FromImage(img);

            //Check if range is not too big
            if (xFrom > max)
                xFrom = max;
            else if (xFrom < min)
                xFrom = min;

            if (xTo > max)
                xTo = max;
            else if (xTo < min)
                xTo = min;

            if (yFrom > max)
                yFrom = max;
            else if (yFrom < min)
                yFrom = min;

            if (yTo > max)
                yTo = max;
            else if (yTo < min)
                yTo = min;

            //Range
            this.xFrom = xFrom;
            this.xTo = xTo;
            this.yFrom = yFrom;
            this.yTo = yTo;

            // Compute 0 and factor for X
            if (xFrom * xTo <= 0) //If X axis is visible
            {
                factorX = picWidth / (-xFrom + xTo);
                zeroX = -xFrom * factorX;
            }
            else if (xFrom < 0) // x axis not visible
            {
                factorX = picWidth / (-xFrom + xTo);
                zeroX = picWidth + (-xTo * factorX);
            }
            else // both positive
            {
                factorX = picWidth / (xTo - xFrom);
                zeroX = (-xFrom * factorX);
            }

            // Compute 0 and factor for Y
            if (yFrom * yTo <= 0)
            {
                factorY = picHeight / (-yFrom + yTo);
                zeroY = yTo * factorY;
            }
            else if (yFrom < 0 && yTo < 0)
            {
                factorY = picHeight / (-yFrom + yTo);
                zeroY = yTo * factorY;
            }
            else
            {
                factorY = picHeight / (yTo - yFrom);
                zeroY = picHeight + (yFrom * factorY);
            }

            //Remove old graph
            Clear();
        }
    }
}

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Diagnostics;
using NumericalLibraries.Bessel;
using NumericalLibraries.Chart.Exceptions;
using NumericalLibraries.Calculator.Enums;
using NumericalLibraries.Calculator.Exceptions;
using NumericalLibraries.Chart.Enums;
using NumericalLibraries.Common;

namespace NumericalLibraries.Chart
{
    public class Chart
    {
    // Zmienne ----------------------------
        double xOd, xDo, yOd, yDo; //Wybrany przedzial
        double zeroX, zeroY; //Ile wynosza miejsca zerowe wykresu w stosunku do wybranego przedzialu
        double wspX, wspY; //Wspolczynniki X i Y, czyli ile jedna jednostka wybranego przez usera przedzialu ma jednostek na moim wykresie
        int picWidth, picHeight;

        readonly double max = 530000000.0;
        readonly double min = -530000000.0;

        PictureBox pWykres;
        Graphics g;

        string function;

        Image img;

        public Image Image
        {
          get { return img; }
        }

        List<PointF> punktyWykresu;

        /// <summary>
        /// Points generated by Draw functions used to draw the chart 
        /// </summary>
        public PointF[] GraphPoints
        {
            get { return punktyWykresu.ToArray(); }
        }

    // Metody -----------------------------
        /// <summary>
        /// Clears old chart and generates new clear chart with coordinate system
        /// </summary>
        public void Clear() //Wyczyszczenie starego wykresu i przygotowanie siatki X i Y
        {
            Font font = new Font("Arial", 7); // Do wypisywania punktow siatki

            g.Clear(Color.White); // Czysci ekran z poprzedniej funkcji

            //Rysowanie siatki X:
            double krok = ((-xOd + xDo) / 6) * wspX;

            if (xOd * xDo <= 0) // Bedzie widoczna os zeroX, wiec rysujemy od zeroX na lewo i od zeroX na prawo
            {
                for (double i = zeroX; i >= zeroX + xOd * wspX; i -= krok)
                {
                    if (i > (xOd * wspX) + zeroX && i < (xDo * wspX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // OŚ -X
                        g.DrawString(Convert.ToString(Math.Round(xOd + i / wspX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }

                for (double i = zeroX; i <= (xDo * wspX) + zeroX; i += krok)
                {
                    if (i > (xOd * wspX) + zeroX && i < (xDo * wspX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // OŚ +X
                        g.DrawString(Convert.ToString(Math.Round(xOd + i / wspX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }
            }
            else if (xOd < 0) // Obie wartosci xOd i xDo sa ujemne
            {
                for (double i = zeroX; i >= zeroX + xOd * wspX; i -= krok)
                {
                    if (i > (xOd * wspX) + zeroX && i < (xDo * wspX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // OŚ -X
                        g.DrawString(Convert.ToString(Math.Round(xOd + i / wspX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }
            }
            else // Obie wartosci sa dodatnie
            {
                for (double i = zeroX; i <= (xDo * wspX) + zeroX; i += krok)
                {
                    if (i > (xOd * wspX) + zeroX && i < (xDo * wspX) + zeroX)
                    {
                        g.DrawLine(Pens.LightGray, (float)(i), 0, (float)(i), img.Height); // OŚ +X
                        g.DrawString(Convert.ToString(Math.Round(xOd + i / wspX, 3)), font, Brushes.DarkGray, (float)(i), picHeight - 15);
                    }
                }
            }

            //Rysowanie siatki Y:
            krok = ((-yOd + yDo) / 6) * wspY;

            if (yOd * yDo <= 0) // Bedzie widoczna os zeroY, wiec rysujemy od zeroY na lewo i od zeroY na prawo
            {
                for (double i = zeroY; i <= zeroY + (-yOd) * wspY; i += krok)
                {
                    if (i < (-yOd * wspY) + zeroY && i > (-yDo * wspY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // OŚ -Y
                        g.DrawString(Convert.ToString(Math.Round(yDo - i / wspY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }

                for (double i = zeroY; i >= zeroY + (-yDo) * wspY; i -= krok)
                {
                    if (i < (-yOd * wspY) + zeroY && i > (-yDo * wspY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // OŚ +Y
                        g.DrawString(Convert.ToString(Math.Round(yDo - i / wspY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }
            }
            else if (yOd < 0) // Obie wartosci yOd i yDo sa ujemne
            {
                for (double i = zeroY; i <= zeroY + (-yOd) * wspY; i += krok)
                {
                    if (i < (-yOd * wspY) + zeroY && i > (-yDo * wspY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // OŚ -Y
                        g.DrawString(Convert.ToString(Math.Round(yDo - i / wspY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }
            }
            else // Obie wartosci sa dodatnie
            {
                for (double i = zeroY; i >= zeroY + (-yDo) * wspY; i -= krok)
                {
                    if (i < (-yOd * wspY) + zeroY && i > (-yDo * wspY) + zeroY)
                    {
                        g.DrawLine(Pens.LightGray, img.Width, (float)(i), 0, (float)(i)); // OŚ +Y
                        g.DrawString(Convert.ToString(Math.Round(yDo - i / wspY, 3)), font, Brushes.DarkGray, 1, (float)(i));
                    }
                }
            }

            //RYSOWANIE OSI OX i OY
            g.DrawLine(Pens.Black, 0, (float)zeroY, img.Width, (float)zeroY); // OŚ X
            g.DrawLine(Pens.Black, (float)zeroX, 0, (float)zeroX, img.Height); // OŚ Y

            font = new Font("Aria", 8);

            //STRZAŁKI I OPIS OSI OX
            g.DrawLine(Pens.Black, (float)img.Width - 12f, (float)zeroY - 5f, (float)img.Width - 2f, (float)zeroY);
            g.DrawLine(Pens.Black, (float)img.Width - 12f, (float)zeroY + 5f, (float)img.Width - 2f, (float)zeroY);
            g.DrawString("x", font, Brushes.Black, (float)img.Width - 13f, (float)zeroY + 3f);

            //STRZAŁKI I OPIS OSI OY
            g.DrawLine(Pens.Black, (float)zeroX - 6f, 10f, (float)zeroX - 1, 2);
            g.DrawLine(Pens.Black, (float)zeroX + 5f, 10f, (float)zeroX + 1, 2);
            g.DrawString("f(x)", font, Brushes.Black, (float)zeroX + 7f, 4f);

            //Wyczyszczenie punktow wykresu
            punktyWykresu = new List<PointF>();
        }

        /// <summary>
        /// Draw the chart
        /// </summary>
        /// <param name="functionType">Function type to draw on chart</param>
        public void Draw(FunctionTypeEnum functionType)
        {
            punktyWykresu.Clear();

            Derivative.Derivative funkcjaWPunkcie = new Derivative.Derivative(function);

            Font font2 = new Font("Arial", 8); // Do wypisywania wzoru funkcji

            List<PointF> punkty = new List<PointF>();

            Pen pen = null;

            for (double i = 0; i < picWidth; i += (double)picWidth / 1000.0)
            {
                float fx = 0;
                double x = (i - zeroX) / wspX;

                switch (functionType)
                {
                    case FunctionTypeEnum.Function:
                        fx = (float)(funkcjaWPunkcie.ComputeFunctionAtPoint(x) * wspY);
                        break;
                    case FunctionTypeEnum.Derivative:
                        fx = (float)(funkcjaWPunkcie.ComputeDerivative(x) * wspY);
                        break;
                    case FunctionTypeEnum.SecondDerivative:
                        fx = (float)(funkcjaWPunkcie.ComputeDerivativeBis(x) * wspY);
                        break;
                    default:
                        throw new NoneGraphOptionCheckedException(); //not reachable code?
                }

                if (fx > max)
                    fx = (float)max;
                else if (fx < min)
                    fx = (float)min;

                punkty.Add(new PointF((float)(i), (float)(zeroY - fx)));
                punktyWykresu.Add(new PointF((float)x, (float)(fx / wspY)));
            }

            //Wypisanie wzoru funkcji
            g.DrawString("f(x) = " + function, font2, Brushes.Black, 3, 3);

            switch (functionType)
            {
                case FunctionTypeEnum.Function:
                    pen = Pens.Blue;
                    break;
                case FunctionTypeEnum.Derivative:
                    pen = Pens.Red;
                    break;
                case FunctionTypeEnum.SecondDerivative:
                    pen = Pens.Green;
                    break;
            }

            //RYSOWANIE WYKRESU
            try
            {
                g.DrawLines(pen, punkty.ToArray());
            }
            catch (Exception)
            {
                //Pozbycie sie NaN - może pomoże
                punkty = punkty.Where(p => !double.IsNaN(p.Y)).ToList();

                try
                {
                    g.DrawLines(pen, punkty.ToArray());
                }
                catch { }
            }           
        }

        /// <summary>
        /// Draw the fourier transform chart
        /// </summary>
        /// <param name="functionType">Function type to draw. Only FT or IFT are correct in this function.</param>
        /// <param name="sampling">Sampling rate</param>
        /// <param name="cutoff">Used with IFT to remove noise from function</param>
        public void DrawFT(FunctionTypeEnum functionType, int sampling, double cutoff = 0.0)
        {
            punktyWykresu.Clear();

            Font font2 = new Font("Arial", 8); // Do wypisywania wzoru funkcji

            List<PointF> punkty = new List<PointF>();
            List<PointF> punktyRevers = new List<PointF>();

            List<PointC> punktyC = new List<PointC>();
            List<PointC> punktyReversC = new List<PointC>();

            Pen pen = null;

            FourierTransform.FourierTransform fft = new FourierTransform.FourierTransform();

            //Obliczenie FFT
            punktyC = fft.Compute(function, sampling, xOd, xDo);

            //Przefiltrowanie
            for (int i = 0; i < punktyC.Count; i++)
            {
                PointC pc = punktyC[i];

                if (Math.Abs(pc.Y.Real) < cutoff)
                    pc.Y = 0;

                punktyC[i] = pc;
            }

            //Obliczenie Reverse FFT
            if (functionType == FunctionTypeEnum.IFT)
                punktyReversC = fft.ComputeInverse(punktyC, sampling, xOd, xDo);

            //Nowe przygotowanie
            if (functionType == FunctionTypeEnum.FT)
                Initialize(function, img.Width, img.Height, 0, sampling + 3, yOd, yDo);

            //Przeskalowanie pkt-ow
            if (functionType == FunctionTypeEnum.FT)
            {
                for (int i = 0; i < punktyC.Count; i++)
                {
                    PointC pc = punktyC[i];

                    punktyWykresu.Add(pc.ToPointF());

                    pc.X = (pc.X * wspX + zeroX);
                    pc.Y = (pc.Y * wspY);

                    if (pc.Y.Real > max)
                        pc.Y = max;
                    else if (pc.Y.Real < min)
                        pc.Y = min;

                    pc.Y = (zeroY - pc.Y);

                    punkty.Add(pc.ToPointF());
                }
            }

            if (functionType == FunctionTypeEnum.IFT)
            {
                //Przeskalowanie pkt-ow Reverse
                for (int i = 0; i < punktyReversC.Count; i++)
                {
                    PointC pc = punktyReversC[i];

                    punktyWykresu.Add(pc.ToPointF());

                    pc.X = (pc.X * wspX + zeroX);
                    pc.Y = (pc.Y * wspY);

                    if (pc.Y.Real > max)
                        pc.Y = max;
                    else if (pc.Y.Real < min)
                        pc.Y = min;

                    //if (Math.Abs(pc.Y.Real) < odciecie)
                    //    pc.Y = 0;

                    pc.Y = (zeroY - pc.Y);

                    punktyRevers.Add(pc.ToPointF());
                }
            }

            //Wypisanie wzoru funkcji
            if (functionType == FunctionTypeEnum.FT)
                g.DrawString("FFT(" + '\u03C9' + ") = " + function, font2, Brushes.Black, 3, 16);
            else
                g.DrawString("RFFT(x) = " + function, font2, Brushes.Black, 3, 16);

            switch (functionType)
            {
                case FunctionTypeEnum.FT:
                    pen = Pens.PaleVioletRed;
                    break;
                case FunctionTypeEnum.IFT:
                    pen = Pens.Red;
                    break;
                default:
                    pen = Pens.Red;
                    break;
            }

            //RYSOWANIE WYKRESU
            try
            {
                if (functionType == FunctionTypeEnum.FT)
                    g.DrawLines(pen, punkty.ToArray());
                else
                    g.DrawLines(pen, punktyRevers.ToArray());
            }
            catch (Exception)
            {
                //Pozbycie sie NaN - może pomoże
                if (functionType == FunctionTypeEnum.FT)
                    punkty = punkty.Where(p => !double.IsNaN(p.Y)).ToList();
                else
                    punktyRevers = punktyRevers.Where(p => !double.IsNaN(p.Y)).ToList();

                try
                {
                    if (functionType == FunctionTypeEnum.FT)
                        g.DrawLines(pen, punkty.ToArray());
                    else
                        g.DrawLines(pen, punktyRevers.ToArray());
                }
                catch { }
            }
        }

        /// <summary>
        /// Draw the differential chart
        /// </summary>
        /// <param name="functionType">Function type. Only Differential or DifferentialII are correct in this function.</param>
        /// <param name="parameters">
        /// 0. Starting point
        /// 1. Starting point function value
        /// 2. Second derivative starting point function value
        /// </param>
        public void DrawDifferential(FunctionTypeEnum functionType, params double[] parameters)
        {
            punktyWykresu.Clear();

            List<PointF> punkty = new List<PointF>();

            Font font2 = new Font("Arial", 8); // Do wypisywania wzoru funkcji

            Pen pen = null;

            //Dostosowanie kroku
            double krok = 0.001;
            double wielkoscPrzedzialu = xDo - xOd;

            if (wielkoscPrzedzialu > 20 && wielkoscPrzedzialu < 50)
                krok = 0.0025;
            else if (wielkoscPrzedzialu >= 50 && wielkoscPrzedzialu < 150)
                krok = 0.005;
            else if (wielkoscPrzedzialu >= 150 && wielkoscPrzedzialu < 500)
                krok = 0.01;
            else if (wielkoscPrzedzialu >= 500)
                krok = 0.05;

            //Idziemy od naszego punktu brzegowego w lewo, a potem w prawo
            switch (functionType)
            {
                case FunctionTypeEnum.Differential:

                    Differential.Differential rozniczka = new Differential.Differential(function);

                    List<PointD> lewo = new List<PointD>();
                    List<PointD> prawo = new List<PointD>();

                    //W lewo
                    if (xOd < parameters[0])
                        lewo = rozniczka.ComputeDifferentialPointsList(xOd, parameters[0], parameters[1], false, krok);

                    //W prawo
                    rozniczka = new Differential.Differential(function);

                    if (xDo >= parameters[0])
                        prawo = rozniczka.ComputeDifferentialPointsList(xDo, parameters[0], parameters[1], false, krok);

                    //ŁĄCZYMY
                    //odwracamy w lewo
                    lewo.Reverse();

                    //dodajemy lewo
                    foreach (PointD point in lewo)
                    {
                        PointF pf = new PointF();

                        punktyWykresu.Add(point.ToPointF());

                        pf.X = (float)(point.X * wspX + zeroX);
                        pf.Y = (float)(point.Y * wspY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        punkty.Add(pf);
                    }

                    //dodajemy prawo
                    foreach (PointD point in prawo)
                    {
                        PointF pf = new PointF();

                        punktyWykresu.Add(point.ToPointF());

                        pf.X = (float)(point.X * wspX + zeroX);
                        pf.Y = (float)(point.Y * wspY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        punkty.Add(pf);
                    }

                    break;
                case FunctionTypeEnum.DifferentialII:

                    Differential.Differential rozniczkaII = new Differential.Differential(function);

                    List<PointD> lewoII = new List<PointD>();
                    List<PointD> prawoII = new List<PointD>();

                    //W lewo
                    if (xOd < parameters[0])
                        lewoII = rozniczkaII.ComputeDifferentialIIPointsList(xOd, parameters[0], parameters[1], parameters[2], false, krok);

                    //W prawo
                    rozniczkaII = new Differential.Differential(function);

                    if (xDo >= parameters[0])
                        prawoII = rozniczkaII.ComputeDifferentialIIPointsList(xDo, parameters[0], parameters[1], parameters[2], false, krok);

                    //ŁĄCZYMY
                    //odwracamy w lewo
                    lewoII.Reverse();

                    foreach (PointD point in lewoII)
                    {
                        //Normalne:
                        PointF pf = new PointF();

                        punktyWykresu.Add(point.ToPointF());

                        pf.X = (float)(point.X * wspX + zeroX);
                        pf.Y = (float)(point.Y * wspY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        punkty.Add(pf);
                    }

                    //dodajemy prawo
                    foreach (PointD point in prawoII)
                    {
                        //Normalne:
                        PointF pf = new PointF();

                        punktyWykresu.Add(point.ToPointF());

                        pf.X = (float)(point.X * wspX + zeroX);
                        pf.Y = (float)(point.Y * wspY);

                        if (pf.Y > max)
                            pf.Y = (float)max;
                        else if (pf.Y < min)
                            pf.Y = (float)min;

                        pf.Y = (float)(zeroY - pf.Y);

                        punkty.Add(pf);
                    }

                    break;
                default:
                    throw new NoneGraphOptionCheckedException(); //not reachable code?
            }

            //Wypisanie wzoru funkcji
            g.DrawString("f(x) = " + function, font2, Brushes.Black, 3, 3);

            switch (functionType)
            {
                case FunctionTypeEnum.Differential:
                    pen = Pens.PaleVioletRed;
                    break;
                case FunctionTypeEnum.DifferentialII:
                    pen = Pens.Maroon;
                    break;
            }

            //RYSOWANIE WYKRESU
            try
            {
                g.DrawLines(pen, punkty.ToArray());
            }
            catch (Exception)
            {
                //Pozbycie sie NaN - może pomoże
                punkty = punkty.Where(p => !double.IsNaN(p.Y)).ToList();
                
                try
                {
                    g.DrawLines(pen, punkty.ToArray());
                }
                catch { }
            }
        }

        /// <summary>
        /// Drawing the Bessel, Neumann or Hypergeometric functions chart
        /// </summary>
        /// <param name="functionType">Function type to draw</param>
        /// <param name="parameters">Chosen function parameters</param>
        public void DrawBessel(BesselFunctionTypeEnum functionType, params double[] parameters)
        {
            punktyWykresu.Clear();

            int indexZmiennej = ZnajdzIndexZmiennej(functionType, parameters);

            BesselNeumanHyper bnh = new BesselNeumanHyper();
            List<PointF> punkty = new List<PointF>();

            //Obliczenie punktow
            if (indexZmiennej != -1)
            {
                for (double i = 0; i < picWidth; i += (double)picWidth / 1000.0)
                {
                    float fx = 0;
                    parameters[indexZmiennej] = (i - zeroX) / wspX;

                    switch (functionType)
                    {
                        case BesselFunctionTypeEnum.Bessel:
                            fx = (float)(bnh.Bessel(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.BesselSphere:
                            fx = (float)(bnh.SphBessel(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.BesselSphereDerivative:
                            fx = (float)(bnh.SphBesselPrim(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.Neumann:
                            fx = (float)(bnh.Neumann(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphere:
                            fx = (float)(bnh.SphNeuman(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphereDerivative:
                            fx = (float)(bnh.SphNeumanPrim(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric01:
                            fx = (float)(bnh.Hyperg_0F_1(parameters[0], parameters[1]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric11:
                            fx = (float)(bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]) * wspY);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric21:
                            fx = (float)(bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]) * wspY);
                            break;
                        default:
                            throw new Exception("Nie wybrano funkcji!"); //not reachable code?
                    }

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    punkty.Add(new PointF((float)(i), (float)(zeroY - fx)));
                    punktyWykresu.Add(new PointF((float)parameters[indexZmiennej], (float)(fx / wspY)));
                }
            }
            else //Dodanie dwóch punktów - funkcja stała
            {
                float fx = 0;

                switch (functionType)
                {
                    case BesselFunctionTypeEnum.Bessel:
                        fx = (float)(bnh.Bessel(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.BesselSphere:
                        fx = (float)(bnh.SphBessel(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.BesselSphereDerivative:
                        fx = (float)(bnh.SphBesselPrim(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.Neumann:
                        fx = (float)(bnh.Neumann(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphere:
                        fx = (float)(bnh.SphNeuman(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphereDerivative:
                        fx = (float)(bnh.SphNeumanPrim(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric01:
                        fx = (float)(bnh.Hyperg_0F_1(parameters[0], parameters[1]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric11:
                        fx = (float)(bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]) * wspY);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric21:
                        fx = (float)(bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]) * wspY);
                        break;
                    default:
                        throw new Exception("Nie wybrano funkcji!"); //not reachable code?
                }

                if (fx > max)
                    fx = (float)max;
                else if (fx < min)
                    fx = (float)min;

                punkty.Add(new PointF((float)(0), (float)(zeroY - fx)));
                punkty.Add(new PointF((float)(picWidth), (float)(zeroY - fx)));
            }         
            
            //RYSOWANIE WYKRESU
            try
            {
                g.DrawLines(Pens.Orange, punkty.ToArray());
            }
            catch (Exception)
            {
                //Pozbycie sie NaN - może pomoże
                punkty = punkty.Where(p => !double.IsNaN(p.Y)).ToList();

                try
                {
                    g.DrawLines(Pens.Orange, punkty.ToArray());
                }
                catch { }
            }            
        }

        /// <summary>
        /// Function that returns reskalled chart parameters
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </summary>
        /// <param name="functionType">Function type</param>
        /// <returns>
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </returns>
        public double[] Reskalling(params FunctionTypeEnum[] functionType)
        {
            Derivative.Derivative funkcjaWPunkcie = new Derivative.Derivative(function); // Do obliczania wartosci funkcji w punkcie
            List<PointF> punkty = new List<PointF>();

            //Obliczenie punktow
            for (double i = 0; i < picWidth; i += (double)picWidth / 100.0)
            {
                float fx = 0;
                double punkt = (i - zeroX) / wspX;

                if (functionType.Contains(FunctionTypeEnum.Function))
                {
                    fx = (float)funkcjaWPunkcie.ComputeFunctionAtPoint(punkt);

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    punkty.Add(new PointF((float)punkt, fx));
                }

                if (functionType.Contains(FunctionTypeEnum.Derivative))
                {
                    fx = (float)funkcjaWPunkcie.ComputeDerivative(punkt);

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    punkty.Add(new PointF((float)punkt, fx));
                }

                if (functionType.Contains(FunctionTypeEnum.SecondDerivative))
                {
                    fx = (float)funkcjaWPunkcie.ComputeDerivativeBis(punkt);

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    punkty.Add(new PointF((float)punkt, fx));
                }
            }

            //Wyciagniecie punktow bez NaN
            List<PointF> nowePunkty = punkty.Where(pkt => (!double.IsNaN(pkt.Y) && !double.IsInfinity(pkt.Y))).ToList();

            if (nowePunkty.Count == 0)
                return new double[] { xOd, xDo, yOd, yDo };

            double minX, maxX;

            //Jak byly jakies NaN to zmieniamy X i powtarzamy reskalling
            if (punkty.Count() > nowePunkty.Count())
            {
                minX = nowePunkty.Select(p => p.X).Min();
                maxX = nowePunkty.Select(p => p.X).Max();

                //Obliczenie +-1%
                double jedenProcentX = Math.Abs(maxX - minX) * 0.01;

                minX += jedenProcentX;
                maxX -= jedenProcentX;

                minX = Math.Round(minX, 2);
                maxX = Math.Round(maxX, 2);

                Chart wykres = new Chart(function, pWykres, minX, maxX, yOd, yDo);

                return wykres.Reskalling(functionType);
            }

            double maxY = nowePunkty.Select(p => p.Y).Max();
            double minY = nowePunkty.Select(p => p.Y).Min();

            //Obliczenie +-5%
            double piecProcentY = Math.Abs(maxY - minY) * 0.05;

            maxY += piecProcentY;
            minY -= piecProcentY;

            maxY = Math.Round(maxY, 2);
            minY = Math.Round(minY, 2);

            if (maxY > max)
                maxY = (float)max;
            else if (maxY < min)
                maxY = (float)min;

            if (minY > max)
                minY = (float)max;
            else if (minY < min)
                minY = (float)min;

            if (minY == maxY)
            {
                minY -= 0.5;
                maxY += 0.5;
            }

            double[] f = new double[] { xOd, xDo, minY, maxY };

            return f;
        }

        /// <summary>
        /// Function that returns reskalled chart parameters for Bessel, Neumann or Hypergeometric functions
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </summary>
        /// <param name="functionType">Function type</param>
        /// <param name="parameters">Chosen function parameters</param>
        /// <returns>
        /// 0. Abscissa from
        /// 1. Abscissa to
        /// 2. Ordinate from
        /// 3. Ordinate to
        /// </returns>
        public double[] Reskalling(BesselFunctionTypeEnum functionType, params double[] parameters)
        {
            int indexZmiennej = ZnajdzIndexZmiennej(functionType, parameters);

            BesselNeumanHyper bnh = new BesselNeumanHyper();
            List<PointF> punkty = new List<PointF>();

            //Obliczenie punktow
            if (indexZmiennej != -1)
            {
                for (double i = 0; i < picWidth; i += (double)picWidth / 100.0)
                {
                    float fx = 0;
                    parameters[indexZmiennej] = (i - zeroX) / wspX;

                    switch (functionType)
                    {
                        case BesselFunctionTypeEnum.Bessel:
                            fx = (float)bnh.Bessel(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.BesselSphere:
                            fx = (float)bnh.SphBessel(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.BesselSphereDerivative:
                            fx = (float)bnh.SphBesselPrim(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.Neumann:
                            fx = (float)bnh.Neumann(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphere:
                            fx = (float)bnh.SphNeuman(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.NeumannSphereDerivative:
                            fx = (float)bnh.SphNeumanPrim(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric01:
                            fx = (float)bnh.Hyperg_0F_1(parameters[0], parameters[1]);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric11:
                            fx = (float)bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]);
                            break;
                        case BesselFunctionTypeEnum.Hypergeometric21:
                            fx = (float)bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]);
                            break;
                        default:
                            throw new Exception("Nie wybrano funkcji!"); //not reachable code?
                    }

                    if (fx > max)
                        fx = (float)max;
                    else if (fx < min)
                        fx = (float)min;

                    punkty.Add(new PointF((float)(parameters[indexZmiennej]), fx));
                }
            }
            else //Dodanie dwóch punktów - funkcja stała
            {
                float fx = 0;

                switch (functionType)
                {
                    case BesselFunctionTypeEnum.Bessel:
                        fx = (float)bnh.Bessel(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.BesselSphere:
                        fx = (float)bnh.SphBessel(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.BesselSphereDerivative:
                        fx = (float)bnh.SphBesselPrim(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.Neumann:
                        fx = (float)bnh.Neumann(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphere:
                        fx = (float)bnh.SphNeuman(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.NeumannSphereDerivative:
                        fx = (float)bnh.SphNeumanPrim(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric01:
                        fx = (float)bnh.Hyperg_0F_1(parameters[0], parameters[1]);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric11:
                        fx = (float)bnh.Hyperg_1F_1(parameters[0], parameters[1], parameters[2]);
                        break;
                    case BesselFunctionTypeEnum.Hypergeometric21:
                        fx = (float)bnh.Hyperg_2F_1(parameters[0], parameters[1], parameters[2], parameters[3]);
                        break;
                    default:
                        throw new Exception("Nie wybrano funkcji!"); //not reachable code?
                }

                if (fx > max)
                    fx = (float)max;
                else if (fx < min)
                    fx = (float)min;

                punkty.Add(new PointF((float)((0 - zeroX) / wspX), fx));
                punkty.Add(new PointF((float)((picWidth - zeroX) / wspX), fx));
            }

            //Wyciagniecie punktow bez NaN
            List<PointF> nowePunkty = punkty.Where(pkt => (!double.IsNaN(pkt.Y) && !double.IsInfinity(pkt.Y))).ToList();

            if (nowePunkty.Count == 0)
                return new double[] { xOd, xDo, yOd, yDo};

            double minX, maxX;

            //Jak byly jakies NaN to zmieniamy X i powtarzamy reskalling
            if (punkty.Count() > nowePunkty.Count())
            {
                minX = nowePunkty.Select(p => p.X).Min();
                maxX = nowePunkty.Select(p => p.X).Max();

                //Obliczenie +-1%
                double jedenProcentX = Math.Abs(maxX - minX) * 0.01;

                minX += jedenProcentX;
                maxX -= jedenProcentX;

                minX = Math.Round(minX, 2);
                maxX = Math.Round(maxX, 2);

                Chart wykres = new Chart(function, pWykres, minX, maxX, yOd, yDo);

                parameters[indexZmiennej] = double.NaN;

                return wykres.Reskalling(functionType, parameters);
            }

            double maxY = nowePunkty.Select(p => p.Y).Max();
            double minY = nowePunkty.Select(p => p.Y).Min();

            //Obliczenie +-5%
            double piecProcentY = Math.Abs(maxY - minY) * 0.05;

            maxY += piecProcentY;
            minY -= piecProcentY;

            maxY = Math.Round(maxY, 2);
            minY = Math.Round(minY, 2);

            if (maxY > max)
                maxY = (float)max;
            else if (maxY < min)
                maxY = (float)min;

            if (minY > max)
                minY = (float)max;
            else if (minY < min)
                minY = (float)min;

            if (minY == maxY)
            {
                minY -= 0.5;
                maxY += 0.5;
            }

            double[] f = new double[] { xOd, xDo, minY, maxY };            

            return f;
        }

        private void NapiszWzorFunkcjiBesselowej(BesselFunctionTypeEnum typFunkcji, double[] parametry, int indexZmiennej)
        {
            Font font = new Font("Arial", 8); // Do wypisywania wzoru funkcji

            string parametryString = string.Empty;

            //Zbudowanie stringu parametrow
            if (typFunkcji == BesselFunctionTypeEnum.Hypergeometric21)
            {
                parametryString += (indexZmiennej != 0) ? parametry[0].ToString() : "x";
                parametryString += ", ";
                parametryString += (indexZmiennej != 1) ? parametry[1].ToString() : "x";
                parametryString += ", ";
                parametryString += (indexZmiennej != 2) ? parametry[2].ToString() : "x";
                parametryString += ", ";
                parametryString += (indexZmiennej != 3) ? parametry[3].ToString() : "x";
            }
            else if (typFunkcji == BesselFunctionTypeEnum.Hypergeometric11)
            {
                parametryString += (indexZmiennej != 0) ? parametry[0].ToString() : "x";
                parametryString += ", ";
                parametryString += (indexZmiennej != 1) ? parametry[1].ToString() : "x";
                parametryString += ", ";
                parametryString += (indexZmiennej != 2) ? parametry[2].ToString() : "x";
            }
            else
            {
                parametryString += (indexZmiennej != 0) ? parametry[0].ToString() : "x";
                parametryString += ", ";
                parametryString += (indexZmiennej != 1) ? parametry[1].ToString() : "x";
            }

            //Wypisanie nazw
            switch (typFunkcji)
            {
                case BesselFunctionTypeEnum.Bessel:
                    g.DrawString("Bessel(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.BesselSphere:
                    g.DrawString("Sferyczna f. Bessela(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.BesselSphereDerivative:
                    g.DrawString("Poch. sfer. f. Bessela(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.Neumann:
                    g.DrawString("Neumann(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.NeumannSphere:
                    g.DrawString("Sferyczna f. Neumanna(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.NeumannSphereDerivative:
                    g.DrawString("Poch. sfer. f. Neumanna(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.Hypergeometric01:
                    g.DrawString("Hipergeometryczna0F1(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.Hypergeometric11:
                    g.DrawString("Hipergeometryczna1F1(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                case BesselFunctionTypeEnum.Hypergeometric21:
                    g.DrawString("Hipergeometryczna2F1(" + parametryString + ")", font, Brushes.Orange, 3, 3);
                    break;
                default:
                    throw new Exception("Nie wybrano funkcji!"); //not reachable code?
            }
        }

        private int ZnajdzIndexZmiennej(BesselFunctionTypeEnum typFunkcji, double[] parametry)
        {
            int indexZmiennej = -1;

            //Znalezienie indexu zmiennej
            if (typFunkcji == BesselFunctionTypeEnum.Bessel || typFunkcji == BesselFunctionTypeEnum.BesselSphere || typFunkcji == BesselFunctionTypeEnum.BesselSphereDerivative || typFunkcji == BesselFunctionTypeEnum.Neumann || typFunkcji == BesselFunctionTypeEnum.NeumannSphere || typFunkcji == BesselFunctionTypeEnum.NeumannSphereDerivative || typFunkcji == BesselFunctionTypeEnum.Hypergeometric01)
            {
                if (double.IsNaN(parametry[0]))
                    indexZmiennej = 0;

                if (double.IsNaN(parametry[1]))
                {
                    if (indexZmiennej == -1)
                        indexZmiennej = 1;
                    else
                        throw new BesseleSecondArgumentException("Zmienna x może występować tylko jako jeden argument!");
                }
            }
            else if (typFunkcji == BesselFunctionTypeEnum.Hypergeometric11)
            {
                if (double.IsNaN(parametry[0]))
                    indexZmiennej = 0;

                if (double.IsNaN(parametry[1]))
                {
                    if (indexZmiennej == -1)
                        indexZmiennej = 1;
                    else
                        throw new BesseleSecondArgumentException("Zmienna x może występować tylko jako jeden argument!");
                }

                if (double.IsNaN(parametry[2]))
                {
                    if (indexZmiennej == -1)
                        indexZmiennej = 2;
                    else
                        throw new BesseleThirdArgumentException("Zmienna x może występować tylko jako jeden argument!");
                }
            }
            else if (typFunkcji == BesselFunctionTypeEnum.Hypergeometric21)
            {
                if (double.IsNaN(parametry[0]))
                    indexZmiennej = 0;

                if (double.IsNaN(parametry[1]))
                {
                    if (indexZmiennej == -1)
                        indexZmiennej = 1;
                    else
                        throw new BesseleSecondArgumentException("Zmienna x może występować tylko jako jeden argument!");
                }

                if (double.IsNaN(parametry[2]))
                {
                    if (indexZmiennej == -1)
                        indexZmiennej = 2;
                    else
                        throw new BesseleThirdArgumentException("Zmienna x może występować tylko jako jeden argument!");
                }

                if (double.IsNaN(parametry[3]))
                {
                    if (indexZmiennej == -1)
                        indexZmiennej = 3;
                    else
                        throw new BesseleFourthArgumentException("Zmienna x może występować tylko jako jeden argument!");
                }
            }

            return indexZmiennej;
        }



    // Konstruktor ------------------------
        /// <summary>
        /// 
        /// </summary>
        /// <param name="function">Function formula to draw</param>
        /// <param name="picGraph">PictureBox to display the chart</param>
        /// <param name="xFrom">Chart abscissa from</param>
        /// <param name="xTo">Chart abscissa to</param>
        /// <param name="yFrom">Chart ordinate from</param>
        /// <param name="yTo">Chart ordinate to</param>
        public Chart(string function, PictureBox picGraph, double xFrom, double xTo, double yFrom, double yTo)
        {
            this.pWykres = picGraph;

            Initialize(function, picGraph.Width, picGraph.Height, xFrom, xTo, yFrom, yTo);
        }

        public Chart(string function, int width, int height, double xFrom, double xTo, double yFrom, double yTo)
        {
            this.pWykres = new PictureBox(); //TODO: to jest bez sensu ale bez tego bedzie exception w Initialize
            pWykres.Width = width;
            pWykres.Height = height;

            Initialize(function, width, height, xFrom, xTo, yFrom, yTo);
        }

        private void Initialize(string funk, int width, int height, double xOd, double xDo, double yOd, double yDo)
        {
            if (xDo == xOd)
                throw new CoordinatesXException();

            if (yDo == yOd)
                throw new CoordinatesYException();

            function = funk;
            picWidth = width;
            picHeight = height;

            img = new Bitmap(picWidth, picHeight);
            pWykres.Image = img;
            g = Graphics.FromImage(img);

            //Zabezpieczenie przed za duzymi granicami wykresu
            if (xOd > max)
                xOd = max;
            else if (xOd < min)
                xOd = min;

            if (xDo > max)
                xDo = max;
            else if (xDo < min)
                xDo = min;

            if (yOd > max)
                yOd = max;
            else if (yOd < min)
                yOd = min;

            if (yDo > max)
                yDo = max;
            else if (yDo < min)
                yDo = min;

            //Przypisanie granic
            this.xOd = xOd;
            this.xDo = xDo;
            this.yOd = yOd;
            this.yDo = yDo;

            // Obliczanie miejsc zerowych i wspolczynnikow X
            if (xOd * xDo <= 0) //Czy kreska zerowa X jest widoczna na wykresie
            {
                wspX = picWidth / (-xOd + xDo);
                zeroX = -xOd * wspX;
            }
            else if (xOd < 0) // Miejsce zerowe nie widoczne, obydwa sa ujemne
            {
                wspX = picWidth / (-xOd + xDo);
                zeroX = picWidth + (-xDo * wspX);
            }
            else // Miejsce zerowe nie widoczne, obydwa sa dodatnie
            {
                wspX = picWidth / (xDo - xOd);
                zeroX = (-xOd * wspX);
            }

            // Obliczanie miejsc zerowych i wspolczynnikow Y
            if (yOd * yDo <= 0)
            {
                wspY = picHeight / (-yOd + yDo);
                zeroY = yDo * wspY;
            }
            else if (yOd < 0 && yDo < 0) // Miejsce zerowe nie widoczne, obydwa sa ujemne
            {
                wspY = picHeight / (-yOd + yDo);
                zeroY = yDo * wspY;
            }
            else // Miejsce zerowe nie widoczne, obydwa sa dodatnie
            {
                wspY = picHeight / (yDo - yOd);
                zeroY = picHeight + (yOd * wspY);
            }

            //Czyszczenie starego wykresu
            Clear();
        }
    }
}
